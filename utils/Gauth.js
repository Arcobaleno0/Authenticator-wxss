/*jshint esversion: 6 */
(() => {
    'use strict';
    var base32 = require('./base32.js');
    var CryptoJS = require('./CryptoJS.js');
    var Buffer = require('./Buffer.js');
    /**
     * Digest the one-time passcode options.
     *
     * @param {Object} options
     * @param {String} options.secret Shared secret key
     * @param {Integer} options.counter Counter value
     * @param {String} [options.encoding="ascii"] Key encoding (ascii, hex,
     *   base32, base64).
     * @param {String} [options.algorithm="sha1"] Hash algorithm (sha1, sha256,
     *   sha512).
     * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)
     *   Shared secret key
     * @return {Buffer} The one-time passcode as a buffer.
     */

    exports.digest = function digest(options) {
        var i;

        // unpack options
        var secret = options.secret;
        var counter = options.counter;
        var encoding = options.encoding || 'ascii';
        var algorithm = (options.algorithm || 'sha1').toLowerCase();

        // Backwards compatibility - deprecated
        if (options.key != null) {
            console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');
            secret = options.key;
        }

        // convert secret to buffer
        if (!Buffer.isBuffer(secret)) {
            secret = encoding === 'base32' ? base32.decode(secret) :
                new Buffer(secret, encoding);
        }

        // create an buffer from the counter
        var buf = new Buffer(8);
        var tmp = counter;
        for (i = 0; i < 8; i++) {
            // mask 0xff over number to get last 8
            buf[7 - i] = tmp & 0xff;

            // shift 8 and get ready to loop over the next batch of 8
            tmp = tmp >> 8;
        }
        // init hmac with the key
        var hmac = CryptoJS.algo.HMAC.create(CryptoJS.algo[algorithm.toUpperCase()], CryptoJS.enc.Latin1.parse(secret.toString('Latin1')));

        // update hmac with the counter
        hmac.update(CryptoJS.enc.Latin1.parse(buf.toString('Latin1')));

        // return the digest
        return new Buffer(hmac.finalize().toString(CryptoJS.enc.Hex), 'hex');
    };

    /**
     * Generate a counter-based one-time token. Specify the key and counter, and
     * receive the one-time password for that counter position as a string. You can
     * also specify a token length, as well as the encoding (ASCII, hexadecimal, or
     * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).
     *
     * @param {Object} options
     * @param {String} options.secret Shared secret key
     * @param {Integer} options.counter Counter value
     * @param {Buffer} [options.digest] Digest, automatically generated by default
     * @param {Integer} [options.digits=6] The number of digits for the one-time
     *   passcode.
     * @param {String} [options.encoding="ascii"] Key encoding (ascii, hex,
     *   base32, base64).
     * @param {String} [options.algorithm="sha1"] Hash algorithm (sha1, sha256,
     *   sha512).
     * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)
     *   Shared secret key
     * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The
     *   number of digits for the one-time passcode.
     * @return {String} The one-time passcode.
     */

    exports.hotp = function hotpGenerate(options) {
        // unpack digits
        // backward compatibility: `length` is also accepted here, but deprecated
        var digits = (options.digits != null ? options.digits : options.length) || 6;
        if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.');

        // digest the options
        var digest = options.digest || exports.digest(options);

        // compute HOTP offset
        var offset = digest[digest.length - 1] & 0xf;

        // calculate binary code (RFC4226 5.4)
        var code = (digest[offset] & 0x7f) << 24 |
            (digest[offset + 1] & 0xff) << 16 |
            (digest[offset + 2] & 0xff) << 8 |
            (digest[offset + 3] & 0xff);

        // left-pad code
        code = new Array(digits + 1).join('0') + code.toString(10);

        // return length number off digits
        return code.substr(-digits);
    };

    // Alias counter() for hotp()
    exports.counter = exports.hotp;

    /**
     * Verify a counter-based one-time token against the secret and return the delta.
     * By default, it verifies the token at the given counter value, with no leeway
     * (no look-ahead or look-behind). A token validated at the current counter value
     * will have a delta of 0.
     *
     * You can specify a window to add more leeway to the verification process.
     * Setting the window param will check for the token at the given counter value
     * as well as `window` tokens ahead (one-sided window). See param for more info.
     *
     * `verifyDelta()` will return the delta between the counter value of the token
     * and the given counter value. For example, if given a counter 5 and a window
     * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds
     * it at counter position 7, it will return `{ delta: 2 }`.
     *
     * @param {Object} options
     * @param {String} options.secret Shared secret key
     * @param {String} options.token Passcode to validate
     * @param {Integer} options.counter Counter value. This should be stored by
     *   the application and must be incremented for each request.
     * @param {Integer} [options.digits=6] The number of digits for the one-time
     *   passcode.
     * @param {Integer} [options.window=0] The allowable margin for the counter.
     *   The function will check "W" codes in the future against the provided
     *   passcode, e.g. if W = 10, and C = 5, this function will check the
     *   passcode against all One Time Passcodes between 5 and 15, inclusive.
     * @param {String} [options.encoding="ascii"] Key encoding (ascii, hex,
     *   base32, base64).
     * @param {String} [options.algorithm="sha1"] Hash algorithm (sha1, sha256,
     *   sha512).
     * @return {Object} On success, returns an object with the counter
     *   difference between the client and the server as the `delta` property (i.e.
     *   `{ delta: 0 }`).
     * @method hotpâ€¤verifyDelta
     * @global
     */
    /**
     * Calculate counter value based on given options. A counter value converts a
     * TOTP time into a counter value by finding the number of time steps that have
     * passed since the epoch to the current time.
     *
     * @param {Object} options
     * @param {Integer} [options.time] Time in seconds with which to calculate
     *   counter value. Defaults to `Date.now()`.
     * @param {Integer} [options.step=30] Time step in seconds
     * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from
     *   which to calculate the counter value. Defaults to 0 (no offset).
     * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)
     *   Initial time in seconds since the UNIX epoch from which to calculate the
     *   counter value. Defaults to 0 (no offset).
     * @return {Integer} The calculated counter value.
     * @private
     */

    exports._counter = function _counter(options) {
        var step = options.step || 30;
        var time = options.time != null ? (options.time * 1000) : Date.now();

        // also accepts 'initial_time', but deprecated
        var epoch = (options.epoch != null ? (options.epoch * 1000) : (options.initial_time * 1000)) || 0;
        if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');

        return Math.floor((time - epoch) / step / 1000);
    };

    /**
     * Generate a time-based one-time token. Specify the key, and receive the
     * one-time password for that time as a string. By default, it uses the current
     * time and a time step of 30 seconds, so there is a new token every 30 seconds.
     * You may override the time step and epoch for custom timing. You can also
     * specify a token length, as well as the encoding (ASCII, hexadecimal, or
     * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).
     *
     * Under the hood, TOTP calculates the counter value by finding how many time
     * steps have passed since the epoch, and calls HOTP with that counter value.
     *
     * @param {Object} options
     * @param {String} options.secret Shared secret key
     * @param {Integer} [options.time] Time in seconds with which to calculate
     *   counter value. Defaults to `Date.now()`.
     * @param {Integer} [options.step=30] Time step in seconds
     * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX
     *   epoch from which to calculate the counter value. Defaults to 0 (no offset).
     * @param {Integer} [options.counter] Counter value, calculated by default.
     * @param {Integer} [options.digits=6] The number of digits for the one-time
     *   passcode.
     * @param {String} [options.encoding="ascii"] Key encoding (ascii, hex,
     *   base32, base64).
     * @param {String} [options.algorithm="sha1"] Hash algorithm (sha1, sha256,
     *   sha512).
     * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)
     *   Shared secret key
     * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)
     *   Initial time in seconds since the UNIX epoch from which to calculate the
     *   counter value. Defaults to 0 (no offset).
     * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The
     *   number of digits for the one-time passcode.
     * @return {String} The one-time passcode.
     */

    exports.totp = function totpGenerate(options) {
        // shadow options
        options = Object.create(options);

        // calculate default counter value
        if (options.counter == null) options.counter = exports._counter(options);

        // pass to hotp
        return this.hotp(options);
    };

    // Alias time() for totp()
    exports.time = exports.totp;
})();